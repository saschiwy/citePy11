#!/usr/bin/python

"""Parse C++ header files and generate a pybind11
binding
"""
import os
import re
import CppHeaderParser as cp


version = __version__ = "0.0.1"


class Enum:
    """Represents an CPP Enum and it's values
    """


    def __init__(self):
        self.name = ""
        self.namespace = ""
        self.options = []
        self.optDesc = []
        self.doxygen = ""


class Argument:
    """Represents an argument or parameter which is given to a method
    """


    def __init__(self):
        self.name = ""
        self.type = ""
        self.constant = False
        self.reference = False


class Method:
    """Represents a member method of a class
    """


    def __init__(self):
        self.name = ""
        self.returnType = ""
        self.namespace = ""
        self.isStatic = False
        self.isConstructor = False
        self.arguments = []
        self.doxygen = ""
        self.requireLambda = False
        self.isConst = False


class Property:
    """Represents a property or member variable of a class
    """


    def __init__(self):
        self.name = ""
        self.doxygen = ""


class Typedef:
    def __init__(self):
        self.fullName = ''
        self.name = ''


class Class:
    """Represents a C++ Class
    """


    def __init__(self):
        self.name = ""
        self.methods = []
        self.namespace = ""
        self.doxygen = ""
        self.properties = []
        self.typedefs = []
        self.isAbstract = False


class CitePy11:
    """This class is the main entry Point for the functionality!
    """


    def __init__(self):
        """Initialize the InterfaceHeader class with the path to the desired Header File
        """
        self.header = None
        self.typedefs = []
        self.filenames = []
        self.enums = []
        self.classes = []


    def parse(self, header_file: list):
        """parse the file specified at Class construction

        Args:
            header_file (str): Path to the header file which shall be parsed
        """

        for header in header_file:
            self.filenames.append(os.path.basename(header))

            with open(header, 'r') as f:
                content = self.__fix_content__(f.read())

            self.header = cp.CppHeader(content, argType='string')

            for e in self.header.enums:
                self.enums.append(self.__parse_enum__(e))
            for cl in self.header.classes:
                self.classes.append(self.__parse_class__(cl))
            for d in self.header.typedefs:
                self.typedefs.append(self.__parse_typedef__(d))

        for c in self.classes:
            has_constructor = False
            for m in c.methods:
                for i, arg in enumerate(m.arguments):
                    m.arguments[i].type = self.__full_type__(arg.type)

                if m.isConstructor:
                    has_constructor = True

            if not has_constructor and not c.isAbstract:
                m = Method()
                m.isConstructor = True
                m.name = c.name
                m.namespace = c.namespace
                m.doxygen = 'Autogenerated constructor'
                c.methods.append(m)


    def create_binding(self, target_file: str, module_name: str):
        """Creates the binding of the header and writes it to the specified file

        Args:
            target_file (str): Path to the target cpp file
            module_name (str): The name the module shall have. Should be the same like the filename
        """
        content = """/* This File is autogenerated with citePy11 (https://github.com/saschiwy/citePy11)
 * author: Sascha Schiwy
 */

// Solve VS2022 Bug https://www.reddit.com/r/cpp_questions/comments/qpo93t/error_c2039_invalid_parameter_is_not_a_member_of/
#ifdef _WIN32
#include <corecrt.h>
#endif
        
#include <pybind11/functional.h>
#include <pybind11/pybind11.h>
#include <pybind11/stl.h>

"""
        for f in self.filenames:
            content += '#include "' + f + '"\n'

        content += """
namespace py = pybind11;
PYBIND11_MODULE(""" + module_name + """, m)
{
    /// ---- Declarations ---- ///   
"""
        for enum in self.enums:
            content += '\t' + 'py::enum_<' + enum.namespace + enum.name + '> ' + \
                       self.__lower_first__(enum.name) + '(m, "' + enum.name + '"' + self.__add_description__(enum.doxygen) + ');\n'

        for c in self.classes:
            content += '\tpy::class_<' + c.namespace + '::' + c.name + '> ' + self.__lower_first__(c.name) + '(m, "' + c.name + '"' + self.__add_description__(
                c.doxygen) + ');\n'

        content += '\n\t/// ---- Enum definitions ---- ///\n'
        for enum in self.enums:
            content += '\t' + self.__lower_first__(enum.name) + '\n'
            for opt in enum.options:
                content += '\t\t.value("' + opt + \
                           '", ' + enum.namespace + enum.name + '::' + opt + ')\n'
            content += '\t\t.export_values();\n'

        # Class Definitions
        content += '\n\t/// ---- Class definitions ---- ///\n'
        for c in self.classes:
            content += '\t' + self.__lower_first__(c.name) + '\n' \
                       + '\t\t/// Static Methods\n'
            for m in c.methods:
                if not m.isStatic:
                    continue

                content += '\t\t.def_static("' + m.name + '", []('

                for i, arg in enumerate(m.arguments):
                    content += arg.type + ' ' + arg.name
                    if i < len(m.arguments) - 1:
                        content += ', '

                content += '){return ' + c.namespace + '::' + c.name + '::' + m.name + '('

                for i, arg in enumerate(m.arguments):
                    content += arg.name
                    if i < len(m.arguments) - 1:
                        content += ', '

                content += ');}' + self.__add_description__(m.doxygen) + ')\n'

            content += '\n\t\t/// Member Variables\n'
            for prop in c.properties:
                content += '\t\t.def_readwrite("' + prop.name + '", &' + c.namespace + '::' + c.name + '::' + prop.name + \
                           self.__add_description__(prop.doxygen) + ')\n'

            content += '\n\t\t/// Constructors\n'
            for m in c.methods:
                if not m.isConstructor:
                    continue

                content += '\t\t.def(py::init<'

                for i, arg in enumerate(m.arguments):
                    content += arg.type
                    if i < len(m.arguments) - 1:
                        content += ', '

                content += '>()' + self.__add_description__(m.doxygen) + ')\n'

            content += '\n\t\t/// Member Methods\n'
            for m in c.methods:
                if m.isStatic:
                    continue
                if m.isConstructor:
                    continue
                if m.requireLambda:
                    continue
                content += '\t\t.def("' + m.name + '", py::overload_cast<'

                for i, arg in enumerate(m.arguments):
                    content += arg.type
                    if i < len(m.arguments) - 1:
                        content += ', '

                content += '>(&' + c.namespace + '::' + c.name + '::' + m.name
                if m.isConst:
                    content += ", py::const_"
                content += ')'
                content += self.__add_description__(m.doxygen) + ')\n'

            # Insert those with lambda wrapping
            for m in c.methods:
                if not m.requireLambda or m.isStatic:
                    continue

                in_out_vals = []

                for arg in m.arguments:
                    if arg.reference and not arg.constant:
                        in_out_vals.append(arg)

                content += '\t\t.def("{0}", []({1}::{2}& self'.format(m.name, c.namespace, c.name)
                for arg in m.arguments:
                    content += ', {} {}'.format(arg.type, arg.name)
                content += ') {'
                for arg in in_out_vals:
                    content += '{0} __{1} = {1}; '.format(arg.type.replace('&', '').strip(), arg.name.replace('&', '').strip())

                if m.returnType != 'void':
                    content += 'const auto __returnCode = '
                content += 'self.{0}('.format(m.name)

                for i, arg in enumerate(m.arguments):
                    if arg in in_out_vals:
                        content += '__'
                    content += arg.name
                    if i < len(m.arguments) - 1:
                        content += ', '

                content += '); return std::make_tuple('
                if m.returnType != 'void':
                    content += '__returnCode, '

                for i, arg in enumerate(in_out_vals):
                    content += '__' + arg.name
                    if i < len(in_out_vals) - 1:
                        content += ', '
                content += '); }' + self.__add_description__(m.doxygen) + ')\n'

            content += '\t;\n\n'
        # End
        content += "}"

        with open(target_file, 'w') as f:
            f.write(content)


    @staticmethod
    def __lower_first__(string: str):
        """Lower the first letter of a string

        Args:
            string (str): The string which shall be manipulated

        Returns:
            str: The resulting string
        """
        if len(string) == 0:
            return string
        else:
            return string[0].lower() + string[1:]


    def __full_type__(self, arg_type: str):
        """Determines the full cpp type with Namespace and Class prefixes

        Args:
            arg_type (str): The type without prefixed

        Returns:
            str: The full type with prefixes
        """
        result = arg_type.replace('&', '').replace('*', '').replace('const', '').strip()

        try:
            ind = [i for i, c in enumerate(self.classes) if c.name == result]
            result = self.classes[ind[0]].namespace + '::' + self.classes[ind[0]].name
        except:
            None
        try:
            ind = [i for i, e in enumerate(self.enums) if e.name == result]
            result = self.enums[ind[0]].namespace + self.enums[ind[0]].name
        except:
            None
        try:
            ind = [i for i, e in enumerate(self.typedefs) if e.name == result]
            result = self.typedefs[ind[0]].fullName
        except:
            None

        if 'const' in arg_type:
            result = 'const ' + result

        for i in range(0, arg_type.count('&')):
            result += '&'

        for i in range(0, arg_type.count('*')):
            result += '*'

        return result


    @staticmethod
    def __parse_enum__(enum_dictionary):
        """Parse an enum struct out of the dictionary Struct of CppHeaderParser

        Args:
            enum_dictionary (dict): The Cpp Header Parser Dictonary

        Returns:
            Enum: The parsed Enum
        """
        enum = Enum()
        enum.name = enum_dictionary['name']
        enum.namespace = enum_dictionary['namespace']
        for opt in enum_dictionary['values']:
            enum.options.append(opt['name'])

        if 'doxygen' in enum_dictionary:
            enum.doxygen = enum_dictionary["doxygen"]

        return enum


    @staticmethod
    def __parse_argument__(arg_dictionary):
        """Parse an argument struct out of the dictionary Struct of CppHeaderParser

        Args:
            arg_dictionary (dict): The Cpp Header Parser Dictionary

        Returns:
            Argument: The parsed Argument
        """
        argument = Argument()
        argument.name = arg_dictionary['name']
        argument.type = arg_dictionary['type']
        argument.constant = arg_dictionary['constant']
        argument.reference = arg_dictionary['reference']
        return argument


    def __parse_method__(self, method_dictionary):
        """Parse a method struct out of the dictionary Struct of CppHeaderParser

        Args:
            method_dictionary (dict): The Cpp Header Parser Dictionary

        Returns:
            Method: The parsed Method
        """
        method = Method()
        method.name = method_dictionary['name'].strip()
        method.returnType = method_dictionary['returns'].strip()
        method.namespace = method_dictionary['namespace'].strip()
        method.isStatic = method_dictionary['static']
        method.isConst = method_dictionary['const']

        if 'doxygen' in method_dictionary:
            method.doxygen = method_dictionary['doxygen'].strip()

        method.isConstructor = method_dictionary['constructor']

        for arg in method_dictionary['parameters']:
            result = self.__parse_argument__(arg)
            method.arguments.append(result)
            if result.reference and not result.constant:
                method.requireLambda = True

        return method


    @staticmethod
    def __parse_property__(property_dictionary):
        """Parse a property struct out of the dictionary Struct of CppHeaderParser

        Args:
            property_dictionary (dict): The Cpp Header Parser Dictionary

        Returns:
            Property: The parsed Property
        """
        prop = Property()
        prop.name = property_dictionary['name']

        if 'doxygen' in property_dictionary:
            prop.doxygen = property_dictionary['doxygen']

        return prop


    def __parse_class__(self, class_dictionary):
        """Parse a class struct out of the dictionary Struct of CppHeaderParser

        Args:
            class_dictionary (dict): The Cpp Header Parser Dictionary

        Returns:
            Class: The parsed Class
        """
        cl = Class()
        cl.name = self.header.classes[class_dictionary]['name']
        cl.namespace = self.header.classes[class_dictionary]['namespace']

        if 'doxygen' in self.header.classes[class_dictionary]:
            cl.doxygen = self.header.classes[class_dictionary]['doxygen']

        for method in self.header.classes[class_dictionary]["methods"]["public"]:
            if method['destructor'] or method['template']:
                continue
            cl.methods.append(self.__parse_method__(method))

        for prop in self.header.classes[class_dictionary]["properties"]["public"]:
            cl.properties.append(self.__parse_property__(prop))

        cl.isAbstract = self.header.classes[class_dictionary]['abstract']
        return cl


    @staticmethod
    def __parse_typedef__(typedefs_dict):
        """Parse a Typedefinition

        Args:
            typedefs_dict (dict): The Type definitions
        
        Returns:
            Typedef: The parsed Type definition
        """

        typedef = Typedef()
        typedef.name = typedefs_dict[typedefs_dict.rfind('::') + 2:]
        typedef.fullName = typedefs_dict

        return typedef


    @staticmethod
    def __fix_content__(content):

        # Enum Class is not detected properly by cppHeaderParser
        content = content.replace('enum class', 'enum')

        # Standard Initialization is not detected properly by CppHeaderParser
        # https://github.com/robotpy/robotpy-cppheaderparser/issues/63
        #   Always like:  Type Name {maybeSomething};
        lines = content.splitlines()

        content = ''
        for line in lines:
            if '{' in line and '}' in line and ';' in line and '(' not in line and ')' not in line:
                line = line.split('{')[0] + ';'
            content += line + '\n'

        return content


    @staticmethod
    def __add_description__(description):
        if len(description) > 0:
            return ', R"doc(' + description + ')doc"'
        else:
            return ''


def parse(header_files: list):
    """Creates the CitePy11 class and accesses parse method and then returning it.
    Used as a faster access to the implementation

    Args:
        header_files (str): The files which shall be parsed and created binding for later on

    Returns:
        CitePy11: The binding creator class
    """
    r = CitePy11()
    r.parse(header_files)

    return r
