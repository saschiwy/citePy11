from citePy11.citepy_config import citepy_config


class CodeDump:

    def __init__(self, config: citepy_config):
        self.full_names = {}
        self.config = config
        self.existing_methods = []

    def __add_description__(self, description):
        if self.config.no_cpp_doc or description is None:
            return ''
        elif len(description) > 0:
            return ', R"(' + description + ')"'
            # return ', R"doc(' + description + ')doc"'
            # return f', "{description}"'
        else:
            return ''

    def __lower_first__(self, string: str):
        """Lower the first letter of a string

        Args:
            string (str): The string which shall be manipulated

        Returns:
            str: The resulting string
        """
        if len(string) == 0:
            return string
        else:
            return string[0].lower() + string[1:]

    def get_cpp_head(self, header_files):
        result = """/* This File is autogenerated with citePy11 (https://github.com/saschiwy/citePy11)
 * author: Sascha Schiwy
 */

// Solve VS2022 Bug https://www.reddit.com/r/cpp_questions/comments/qpo93t/error_c2039_invalid_parameter_is_not_a_member_of/
#ifdef _WIN32
#include <corecrt.h>
#endif
        
#include <pybind11/functional.h>
#include <pybind11/pybind11.h>
#include <pybind11/stl.h>

"""
        for header_file in header_files:
            result += f'#include "{header_file}"\n'

        result += """    

namespace py = pybind11;

"""
        return result

    def add_module(self, content, module_name):
        return content + f'PYBIND11_MODULE(__{module_name}__, m) {{\n'

    @staticmethod
    def get_cpp_template():
        return """/* 
     * This File is autogenerated with citePy11 (https://github.com/saschiwy/citePy11)
     * author: Sascha Schiwy
     */
    
    // Solve VS2022 Bug https://www.reddit.com/r/cpp_questions/comments/qpo93t/error_c2039_invalid_parameter_is_not_a_member_of/
    #ifdef _WIN32
    #include <corecrt.h>
    #endif
            
    #include <pybind11/functional.h>
    #include <pybind11/pybind11.h>
    #include <pybind11/stl.h>
    
    """

    def add_namespace(self, content, namespace):
        content += 'namespace ' + namespace + ' {\n'
        return content

    def close_module(self, content):
        return content + '}\n'

    def close_namespace(self, content, namespace):
        return content + '} // namespace ' + namespace + '\n'

    def add_enums(self, content, enums, namespace_prefix):
        for enum in enums:
            name = enum.typename.segments[0].name
            full_name = namespace_prefix + name
            self.full_names[name] = full_name

            content += 'py::enum_<' + full_name + '> ' + '(m, "' + self.__get_full_pybind_name__(
                name) + '"' + self.__add_description__(
                enum.doxygen) + ')\n'
            for opt in enum.values:
                content += '\t.value("' + opt.name + '", ' + full_name + '::' + opt.name + ')\n'
            content += '\t.export_values();\n\n'

        return content

    def add_functions(self, content, functions, namespace_prefix):
        return content

    def add_classes(self, content, classes, namespace_prefix):
        for clas in classes:
            name = clas.class_decl.typename.segments[0].name
            full_name = namespace_prefix + name
            prefix = full_name + '::'
            self.full_names[name] = full_name

            content = self.add_enums(content, clas.enums, prefix)
            content = self.add_classes(content, clas.classes, prefix)

            content += 'py::class_<' + full_name + '> ' + '(m, "' + self.__get_full_pybind_name__(
                name) + '"' + self.__add_description__(
                clas.class_decl.doxygen) + ')\n'
            content = self.add_fields(content, clas.fields, prefix)
            content = self.add_methods(content, clas.methods, prefix)
            content += ';\n\n'

        return content

    def add_fields(self, content, fields, namespace_prefix):
        for field in fields:
            if field.access != 'public':
                continue

            if field.constexpr:
                continue

            content += '.def_readwrite("' + field.name + '", &' + namespace_prefix + field.name + \
                       self.__add_description__(field.doxygen) + ')\n'

        return content

    def add_methods(self, content, methods, namespace_prefix):
        has_constructor = False
        is_virtual = False

        for method in methods:
            name = method.name.segments[0].name
            if method.pure_virtual:
                is_virtual = True

            if method.access != 'public':
                continue

            if method.constexpr:
                continue

            if method.constructor:
                has_constructor = True
                content += '.def(py::init<' + self.__add_parameters__(method.parameters, types_only=True) + '>()'
                content += self.__add_description__(method.doxygen) + ')\n'
                continue

            if method.destructor:
                continue

            if method.deleted:
                continue

            if method.template:
                continue

            begin = '.def'
            if method.static:
                begin += '_static'

            if len(self.__get_ref_params__(method.parameters)) > 0:
                content = self.__add_reference_method__(content, method, name, begin, namespace_prefix[:-2])
            else:
                content = self.__add_value_method__(content, method, name, namespace_prefix, begin)

        if not has_constructor and not is_virtual:
            content += '.def(py::init<>())'

        return content

    def __add_parameters__(self, parameters, types_only=False):
        result = ''
        for i, arg in enumerate(parameters):

            # Check if attribute 'typenames' exists
            if hasattr(arg.type, 'typename'):
                t = self.__get_type__(arg.type.typename.segments)
                if arg.type.const:
                    t = 'const ' + t

            elif hasattr(arg.type, 'ref_to'):
                t = self.__get_type__(arg.type.ref_to.typename.segments) + '&'
                if arg.type.ref_to.const:
                    t = 'const ' + t

            else:
                raise Exception('Unknown type')

            if types_only:
                result += t
            else:
                result += t + ' ' + arg.name
            if i < len(parameters) - 1:
                result += ', '
        return result

    def __get_type__(self, segments):

        result = segments[0].name
        result = self.__add_specialization__(result, segments[0])

        for seg in segments[1:]:
            result += '::' + seg.name
            result = self.__add_specialization__(result, seg)

        if result in self.full_names:
            result = self.full_names[result]

        return result

    def __add_specialization__(self, result, segment):

        if not hasattr(segment, 'specialization'):
            return result

        if segment.specialization is None:
            return result

        result += '<'
        for i, arg in enumerate(segment.specialization.args):
            result += self.__get_type__(arg.arg.typename.segments)
            if i < len(segment.specialization.args) - 1:
                result += ', '
        result += '>'
        return result

    def __add_value_method__(self, content, method, name, namespace_prefix, begin):
        content += begin + '("' + name + '", py::overload_cast<'
        content += self.__add_parameters__(method.parameters, types_only=True)
        content += '>(&' + namespace_prefix + name

        if method.const:
            content += ', py::const_'

        content += self.__add_description__(method.doxygen) + '))\n'
        return content

    def __get_ref_params__(self, parameters):
        ref_params = []
        for arg in parameters:
            if hasattr(arg.type, 'ref_to') and not arg.type.ref_to.const:
                ref_params.append(arg)
        return ref_params

    def __add_reference_method__(self, content, method, name, begin, class_name):
        content += begin + '("' + name + '", [](' + class_name + '& self'
        content += ', ' + self.__add_parameters__(method.parameters, types_only=False) + ') {'

        ref_params = self.__get_ref_params__(method.parameters)

        for arg in ref_params:
            content += 'auto __' + arg.name + ' = ' + arg.name + '; '

        type_name = self.__get_type__(method.return_type.typename.segments)
        if type_name != 'void':
            content += 'const auto __returnCode = '

        content += 'self.' + name + '('

        param_names = self.__get_param_names__(method.parameters)
        for i, arg in enumerate(param_names):
            if arg in ref_params:
                content += '__'
            content += arg
            if i < len(param_names) - 1:
                content += ', '

        content += '); return std::make_tuple('
        if type_name != 'void':
            content += '__returnCode, '

        for i, arg in enumerate(ref_params):
            content += '__' + arg.name
            if i < len(ref_params) - 1:
                content += ', '

        content += '); }' + self.__add_description__(method.doxygen) + ')\n'
        return content

    def __get_param_names__(self, parameters):
        result = []
        for arg in parameters:
            result.append(arg.name)
        return result

    def find_typedefs(self, content, namespace_prefix):
        for typedef in content.typedefs:
            name = typedef.name
            full_name = namespace_prefix + name
            self.full_names[name] = full_name

    def get_python_head(self, module_name):
        result = """ # This File is autogenerated with citePy11 (Author: Sascha Schiwy)
        
import os
import sys
import enum

script_path = os.path.dirname(os.path.realpath(__file__))
sys.path.append(script_path)
"""

        result += f'\nimport __{module_name}__ as cpp_m\n\n'
        return result

    def get_python_content(self, result, content):
        for c in content:
            result = self.__get_python_namespace__(result, c.namespace)
        return result

    def __get_python_namespace__(self, result, content, nested_prefix=''):

        if len(content.name) > 0:
            result += f'{nested_prefix}class {content.name}:\n'
            nested_prefix = nested_prefix + '    '

        for c in content.classes:
            result = self.__get_python_class__(result, c, nested_prefix)

        # for c in content.enums:
        #     result += self.__get_python_enum__(result, c)
        #
        # for c in content.functions:
        #     result += self.__get_python_function__(result, c)

        for namespace in content.namespaces:
            t = content.namespaces[namespace]
            result = self.__get_python_namespace__(result, t, nested_prefix)

        return result

    def __get_python_class__(self, result, c, nested_prefix):
        name = c.class_decl.typename.segments[0].name
        result += f'{nested_prefix}class {name}:\n'

        for e in c.classes:
            result = self.__get_python_class__(result, e, nested_prefix + '    ')

        for e in c.enums:
            result = self.__get_python_enum__(result, e, nested_prefix + '    ')

        if not self.__has_default_constructor__(c) and not self.__has_custom_constructor__(c):
            constr = self.__add_python_constructor__(name)
            for l in constr.split('\n'):
                result += nested_prefix + l + '\n'

        if self.__has_custom_constructor__(c):
            result += self.__add_python_custom_constructor__(c, nested_prefix + '    ')

        for e in c.fields:
            result = self.__get_python_field__(result, e, f'{nested_prefix}    ')

        self.existing_methods = []
        for m in c.methods:
            result = self.__get_python_method__(result, m, nested_prefix, name)

        return result + '\n'

    def __get_python_enum__(self, result, e, nested_prefix):
        result += f'{nested_prefix}class {e.typename.segments[0].name}(enum.Enum):\n'

        last_val = -1
        for opt in e.values:
            if opt.value is None:
                last_val += 1
            else:
                last_val = opt.value
            result += f'{nested_prefix}    {opt.name} = {last_val}\n'

        return result + '\n'

    def __get_python_method__(self, result, m, nested_prefix, class_name=None):
        if m.access != 'public':
            return result

        if m.destructor:
            return result

        if m.constructor and len(m.parameters) == 0:
            return result

        name = m.name.segments[0].name
        full_method_name = self.__get_full_cpp_method_name__(m, class_name)
        if full_method_name in self.config.methods_to_ignore:
            return result

        method_string = self.__create_python_method__(m, name, class_name)
        if method_string in self.existing_methods:
            return result

        self.existing_methods.append(method_string)
        for l in method_string.split('\n'):
            result += nested_prefix + '    ' + l + '\n'

        return result

    def __get_python_field__(self, result, e, nested_prefix):
        if e.access != 'public':
            return result

        name = e.name

        result += f'{nested_prefix}@property\n'
        result += f'{nested_prefix}def {name}(self):\n'
        result += f'{nested_prefix}    return self.__m__.{name}\n\n'

        result += f'{nested_prefix}@{name}.setter\n'
        result += f'{nested_prefix}def {name}(self, value):\n'
        result += f'{nested_prefix}    self.__m__.{name} = value\n\n'

        return result

    def __get_full_python_name__(self, name):
        if name in self.full_names:
            return self.full_names[name].replace('::', '.')
        else:
            return name

    def __get_full_pybind_name__(self, name):
        if name in self.full_names:
            return self.full_names[name].replace('::', '_')
        else:
            return name

    def __has_default_constructor__(self, c):
        for m in c.methods:
            if m.constructor and len(m.parameters) == 0:
                return True
        return False

    def __add_python_constructor__(self, name, params=None):

        if params is None:
            params = []

        result = 'def __init__(self'

        for i, arg in enumerate(params):
            result += ', ' + arg.name

        result += '):\n'
        result += f'    self.__m__ = cpp_m.{self.__get_full_pybind_name__(name)}('

        for i, arg in enumerate(params):
            result += arg.name
            if i < len(params) - 1:
                result += ', '

        result += ')\n\n'
        return result

    def __has_custom_constructor__(self, c):
        name = c.class_decl.typename.segments[0].name
        if name in self.full_names:
            name = self.full_names[name]
        else:
            return False
        if name in self.config.custom_python_constructor:
            return True
        else:
            return False

    def __add_python_custom_constructor__(self, c, nested_prefix):
        name = c.class_decl.typename.segments[0].name
        result = nested_prefix + 'def __init__(self):\n'
        result += f'{nested_prefix}    {self.config.custom_python_constructor[self.full_names[name]]}\n\n'
        return result

    def __get_full_cpp_method_name__(self, m, class_name):
        name = m.name.segments[0].name
        if class_name not in self.full_names:
            return name

        full_class_name = self.full_names[class_name]
        return full_class_name + '::' + name

    def __create_python_method__(self, m, name, class_name):
        result = ''
        if m.constructor:
            result += self.__add_python_constructor__(class_name, m.parameters)
        else:
            result += f'def {name}(self'

            for i, arg in enumerate(m.parameters):
                result += ', ' + arg.name

            result += '):\n'

            if m.static:
                result += f'    return cpp_m.{self.__get_full_pybind_name__(class_name)}.{name}('
                for i, arg in enumerate(m.parameters):
                    result += arg.name
                    if i < len(m.parameters) - 1:
                        result += ', '

                result += ')\n'

            else:
                result += f'    return self.__m__.{name}('
                for i, arg in enumerate(m.parameters):
                    result += arg.name
                    if i < len(m.parameters) - 1:
                        result += ', '

                result += ')\n'

        return result
