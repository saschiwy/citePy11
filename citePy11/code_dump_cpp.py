from citePy11.citepy_config import citepy_config
from citePy11.citepy_helper import get_cpp_type


class CodeDumpCpp:

    def __init__(self, config: citepy_config):
        self.full_names = {}
        self.config = config
        self.existing_methods = []

    def __add_description__(self, description):
        if self.config.no_cpp_doc or description is None:
            return ''
        elif len(description) > 0:
            return ', R"(' + description + ')"'
            # return ', R"doc(' + description + ')doc"'
            # return f', "{description}"'
        else:
            return ''

    def __lower_first__(self, string: str):
        """Lower the first letter of a string

        Args:
            string (str): The string which shall be manipulated

        Returns:
            str: The resulting string
        """
        if len(string) == 0:
            return string
        else:
            return string[0].lower() + string[1:]

    def get_cpp_head(self, header_files):
        result = """/* This File is autogenerated with citePy11 (https://github.com/saschiwy/citePy11)
 * author: Sascha Schiwy
 */

// Solve VS2022 Bug https://www.reddit.com/r/cpp_questions/comments/qpo93t/error_c2039_invalid_parameter_is_not_a_member_of/
#ifdef _WIN32
#include <corecrt.h>
#endif
        
#include <pybind11/functional.h>
#include <pybind11/pybind11.h>
#include <pybind11/stl.h>

"""
        for header_file in header_files:
            result += f'#include "{header_file}"\n'

        result += """    

namespace py = pybind11;

"""
        return result

    def add_module(self, content, module_name):
        return content + f'PYBIND11_MODULE(__{module_name}__, m) {{\n'

    @staticmethod
    def get_cpp_template():
        return """/* 
     * This File is autogenerated with citePy11 (https://github.com/saschiwy/citePy11)
     * author: Sascha Schiwy
     */
    
    // Solve VS2022 Bug https://www.reddit.com/r/cpp_questions/comments/qpo93t/error_c2039_invalid_parameter_is_not_a_member_of/
    #ifdef _WIN32
    #include <corecrt.h>
    #endif
            
    #include <pybind11/functional.h>
    #include <pybind11/pybind11.h>
    #include <pybind11/stl.h>
    
    """

    def close_module(self, content):
        return content + '}\n'

    def close_namespace(self, content, namespace):
        return content + '} // namespace ' + namespace + '\n'

    def add_enums(self, content, enums, namespace_prefix):
        for enum in enums:
            name = enum.typename.segments[0].name
            full_name = namespace_prefix + name
            self.full_names[name] = full_name

            content += 'py::enum_<' + full_name + '> ' + '(m, "' + self.__get_full_pybind_name__(
                name) + '"' + self.__add_description__(
                enum.doxygen) + ')\n'
            for opt in enum.values:
                content += '\t.value("' + opt.name + '", ' + full_name + '::' + opt.name + ')\n'
            content += '\t.export_values();\n\n'

        return content

    def add_functions(self, content, functions, namespace_prefix):
        return content

    def add_classes(self, content, classes, namespace_prefix):
        for clas in classes:
            name = clas.class_decl.typename.segments[0].name
            full_name = namespace_prefix + name
            prefix = full_name + '::'
            self.full_names[name] = full_name

            self.find_typedefs(clas, prefix)
            content = self.add_enums(content, clas.enums, prefix)
            content = self.add_classes(content, clas.classes, prefix)

            content += 'py::class_<' + full_name + '> ' + '(m, "' + self.__get_full_pybind_name__(
                name) + '"' + self.__add_description__(
                clas.class_decl.doxygen) + ')\n'
            content = self.add_fields(content, clas.fields, prefix)
            content = self.add_methods(content, clas.methods, prefix)
            content += ';\n\n'

        return content

    def add_fields(self, content, fields, namespace_prefix):
        for field in fields:
            if field.access != 'public':
                continue

            if field.constexpr:
                continue

            content += '.def_readwrite("' + field.name + '", &' + namespace_prefix + field.name + \
                       self.__add_description__(field.doxygen) + ')\n'

        return content

    def add_methods(self, content, methods, namespace_prefix):
        has_constructor = False
        is_virtual = False

        for method in methods:
            name = method.name.segments[0].name
            if method.pure_virtual:
                is_virtual = True

            if method.access != 'public':
                continue

            if method.constexpr:
                continue

            if method.constructor:
                has_constructor = True
                content += '.def(py::init<' + self.__add_parameters__(method.parameters, types_only=True) + '>()'
                content += self.__add_description__(method.doxygen) + ')\n'
                continue

            if method.destructor:
                continue

            if method.deleted:
                continue

            if method.template:
                continue

            if method.operator is not None:
                if method.operator not in self.config.operator_map:
                    continue
                python_name = self.config.operator_map[method.operator]
            else:
                python_name = name

            begin = '.def'
            if method.static:
                begin += '_static'

            if len(self.__get_ref_params__(method.parameters)) > 0:
                content = self.__add_reference_method__(content, method, name, python_name, begin,
                                                        namespace_prefix[:-2])
            else:
                content = self.__add_value_method__(content, method, name, python_name, namespace_prefix, begin)

        if not has_constructor and not is_virtual:
            content += '.def(py::init<>())'

        return content

    def __add_parameters__(self, parameters, types_only=False):
        result = ''
        for i, arg in enumerate(parameters):

            # Check if attribute 'typenames' exists
            if hasattr(arg.type, 'typename'):
                t = self.__get_type__(arg.type.typename.segments)
                if arg.type.const:
                    t = 'const ' + t

            elif hasattr(arg.type, 'ref_to'):
                t = 'const ' + self.__get_type__(arg.type.ref_to.typename.segments) + '&'

            else:
                raise Exception('Unknown type')

            if types_only:
                result += t
            else:
                result += t + ' ' + arg.name
            if i < len(parameters) - 1:
                result += ', '
        return result

    def __get_type__(self, segments):

        result = get_cpp_type(segments)

        if result in self.full_names:
            result = self.full_names[result]

        return result

    def __add_value_method__(self, content, method, name, python_name, namespace_prefix, begin):
        content += begin + '("' + python_name + '", py::overload_cast<'
        content += self.__add_parameters__(method.parameters, types_only=True)
        content += '>(&' + namespace_prefix + name

        if method.const:
            content += ', py::const_'

        content += self.__add_description__(method.doxygen) + '))\n'
        return content

    def __get_ref_params__(self, parameters):
        ref_params = []
        for arg in parameters:
            if hasattr(arg.type, 'ref_to') and not arg.type.ref_to.const:
                ref_params.append(arg)
        return ref_params

    def __add_reference_method__(self, content, method, name, python_name, begin, class_name):
        content += begin + '("' + python_name + '", [](' + class_name + '& self'
        content += ', ' + self.__add_parameters__(method.parameters, types_only=False) + ') {'

        ref_params = self.__get_ref_params__(method.parameters)

        for arg in ref_params:
            content += 'auto __' + arg.name + ' = ' + arg.name + '; '

        number_of_return_values = len(ref_params)

        type_name = self.__get_type__(method.return_type.typename.segments)
        if type_name != 'void':
            content += 'const auto __returnCode = '
            number_of_return_values += 1

        content += 'self.' + name + '('

        param_names = self.__get_param_names__(method.parameters)
        for i, arg in enumerate(param_names):
            if self.__is_in_params__(arg, ref_params):
                content += '__'
            content += arg
            if i < len(param_names) - 1:
                content += ', '

        if number_of_return_values > 1:
            content += '); return std::make_tuple('
            if type_name != 'void':
                content += '__returnCode, '

            for i, arg in enumerate(ref_params):
                content += '__' + arg.name
                if i < len(ref_params) - 1:
                    content += ', '

            content += ');'

        else:
            content += f'); return __{ref_params[0].name};'

        content += '}' + self.__add_description__(method.doxygen) + ')\n'
        return content

    def __get_param_names__(self, parameters):
        result = []
        for arg in parameters:
            result.append(arg.name)
        return result

    def find_typedefs(self, content, namespace_prefix):
        for typedef in content.typedefs:
            name = typedef.name
            full_name = namespace_prefix + name
            self.full_names[name] = full_name

    def __get_full_pybind_name__(self, name):
        if name in self.full_names:
            return self.full_names[name].replace('::', '_')
        else:
            return name

    def __is_in_params__(self, arg, ref_params):
        for ref in ref_params:
            if ref.name == arg:
                return True
        return False
