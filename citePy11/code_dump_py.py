from citePy11.simpleDoxyParser import *
from citePy11.code_dump_cpp import CodeDumpCpp


class CodeDumpPy:
    def __init__(self, code_dump_cpp: CodeDumpCpp, config):
        self.config = config
        self.dum_cpp = code_dump_cpp
        self.current_namespace = ''

    @staticmethod
    def get_python_head(module_name):
        result = """ # This File is autogenerated with citePy11 (Author: Sascha Schiwy)
        
import os
import sys
import enum

script_path = os.path.dirname(os.path.realpath(__file__))
sys.path.append(script_path)
"""

        result += f'\nimport __{module_name}__ as cpp_m\n\n'
        return result

    def get_python_content(self, result, content):
        result = ''
        for c in content:
            result += self.__get_python_namespace__(c.namespace, parent_namespace='')
        return result

    def __get_python_namespace__(self, content, parent_namespace=''):
        namespace_name = content.name

        if len(parent_namespace) > 0:
            full_namespace = f'{parent_namespace}.{namespace_name}'
            namespace_nesting = len(full_namespace.split('.')) * '    '

        elif len(namespace_name) > 0:
            full_namespace = namespace_name
            namespace_nesting = ''
        else:
            full_namespace = ''
            namespace_nesting = ''

        result = ''
        if len(namespace_name) > 0:
            result += f'class {namespace_name}:\n'

        full_pybind_name = f'cpp_m.{full_namespace.replace(".", "_")}'

        for e in content.enums:
            enum_lines = self.__create_enum__(e, full_pybind_name)
            for li in enum_lines.split('\n'):
                result += f'    {li}\n'

        for c in content.classes:
            class_lines = self.__create_class__(c, full_pybind_name, full_namespace)
            for li in class_lines.split('\n'):
                result += f'    {li}\n'

        for namespace in content.namespaces:
            t = content.namespaces[namespace]
            namespace_lines = self.__get_python_namespace__(t, full_namespace)
            for li in namespace_lines.split('\n'):
                result += f'{namespace_nesting}{li}\n'

        return result

    def __create_enum__(self, enum, full_pybind_name):
        enum_name = enum.typename.segments[0].name
        full_pybind_name += f'_{enum_name}'

        result = f'class {enum_name}(enum.Enum):\n{self.__get_class_docstring__(enum.doxygen)}'

        for enum_value in enum.values:
            val_name = enum_value.name
            result += f'    {val_name} = {full_pybind_name}.{val_name}\n'

        return result

    def __create_class__(self, c, full_pybind_name, python_namespace):
        class_name = c.class_decl.typename.segments[0].name
        full_pybind_name += f'_{class_name}'
        full_python_name = f'{python_namespace}.{class_name}'

        result = f'class {class_name}({full_pybind_name}):\n'

        if c.class_decl.doxygen is not None:
            doc = create_method_docstring(parse_doxygen_comment(c.class_decl.doxygen))
            for li in doc.split('\n'):
                result += f'    {li}\n'

        for e in c.enums:
            enum_lines = self.__create_enum__(e, full_pybind_name)
            for li in enum_lines.split('\n'):
                result += f'    {li}\n'

        for f in c.fields:
            if f.access != 'public':
                continue

            field_lines = self.__create_field__(f, full_python_name)
            for li in field_lines.split('\n'):
                result += f'    {li}\n'

        for c in c.classes:
            if c.access != 'public':
                continue

            class_lines = self.__create_class__(c, full_pybind_name, full_python_name)
            for li in class_lines.split('\n'):
                result += f'    {li}\n'

        methods = self.__get_class_methods__(c, full_python_name)
        for li in methods.split('\n'):
            result += f'    {li}\n'

        methods = self.__get_static_methods__(c, full_python_name, class_name)
        for li in methods.split('\n'):
            result += f'    {li}\n'

        return result

    def __create_field__(self, f, full_pybind_name):
        field_name = f.name

        result = '@property\n'
        result += f'def {field_name}(self):\n'

        if f.doxygen is not None:
            doc = create_field_docstring(f.doxygen)
            for li in doc.split('\n'):
                result += f'    {li}\n'

        result += f'    return super({full_pybind_name}, {full_pybind_name}).{field_name}.__get__(self)\n\n'
        result += f'@{field_name}.setter\n'
        result += f'def {field_name}(self, value):\n'
        result += f'    super({full_pybind_name}, {full_pybind_name}).{field_name}.__set__(self, value)\n'

        return result

    def __get_class_docstring__(self, doxygen):
        if doxygen is None:
            return ''
        doc = create_method_docstring(parse_doxygen_comment(doxygen))
        result = ''
        for li in doc.split('\n'):
            result += f'    {li}\n'
        return result

    def __get_class_methods__(self, methods, namespace):
        # Collect all methods and overloaded methods with the number of parameters and doxygen
        method_dict = {}
        has_constructor = False

        for m in methods.methods:
            if m.access != 'public':
                continue

            if m.destructor:
                continue

            if m.static:
                continue

            name = m.name.segments[0].name
            cpp_namespace = namespace.replace(".", "::")
            if f'{cpp_namespace}::{name}' in self.config.methods_to_ignore:
                continue

            if m.constructor:
                has_constructor = True
                name = '__init__'

            if name not in method_dict:
                method_dict[name] = []

            method_dict[name].append((len(m.parameters), m.doxygen, m.return_type))

        if not has_constructor:
            method_dict['__init__'] = [(0, None, None)]

        result = ''
        for m in method_dict:
            tag = 'if'
            handled_number_of_params = []
            result += f'def {m}(self, *args):\n'

            for p in method_dict[m]:
                if p[0] in handled_number_of_params:
                    continue

                result += f'    {tag} len(args) == {p[0]}:\n'
                if p[2] is None:
                    ret_type = ''
                else:
                    ret_type = 'return '

                result += f'        {ret_type}super().{m}('

                if p[0] > 0:
                    for i in range(p[0]):
                        result += f'args[{i}], '
                    result = result[:-2]
                result += ')\n\n'
                tag = 'elif'

                handled_number_of_params.append(p[0])

            result += f'    else:\n'
            result += f'        raise Exception("No matching method found for {m}")\n\n'

        return result

    def __get_static_methods__(self, methods, namespace, class_name):
        # Collect all methods and overloaded methods with the number of parameters and doxygen
        method_dict = {}

        for m in methods.methods:
            if m.access != 'public':
                continue

            if not m.static:
                continue

            name = m.name.segments[0].name
            cpp_namespace = namespace.replace(".", "::")
            if f'{cpp_namespace}::{name}' in self.config.methods_to_ignore:
                continue

            if name not in method_dict:
                method_dict[name] = []

            method_dict[name].append((len(m.parameters), m.doxygen, m.return_type))

        result = ''
        for m in method_dict:
            tag = 'if'
            handled_number_of_params = []
            result += f'@staticmethod\ndef {m}(*args):\n'

            for p in method_dict[m]:
                if p[0] in handled_number_of_params:
                    continue

                result += f'    {tag} len(args) == {p[0]}:\n'
                if p[2] is None:
                    ret_type = ''
                else:
                    ret_type = 'return '

                full_pybind_name = f'{namespace.replace(".", "_")}'
                result += f'        {ret_type}cpp_m.{full_pybind_name}.{m}('

                if p[0] > 0:
                    for i in range(p[0]):
                        result += f'args[{i}], '
                    result = result[:-2]
                result += ')\n\n'
                tag = 'elif'

                handled_number_of_params.append(p[0])

            result += f'    else:\n'
            result += f'        raise Exception("No matching method found for {m}")\n\n'

        return result
