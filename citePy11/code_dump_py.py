from citePy11.simpleDoxyParser import *
from citePy11.code_dump_cpp import CodeDumpCpp


class CodeDumpPy:
    def __init__(self, code_dump_cpp: CodeDumpCpp, config):
        self.config = config
        self.dum_cpp = code_dump_cpp
        self.current_namespace = ''

    @staticmethod
    def get_python_head(module_name):
        result = """ # This File is autogenerated with citePy11 (Author: Sascha Schiwy)
        
import os
import sys
import enum

script_path = os.path.dirname(os.path.realpath(__file__))
sys.path.append(script_path)
"""

        result += f'\nimport __{module_name}__ as cpp_m\n\n'
        return result

    def get_python_content(self, result, content):
        result = ''
        for c in content:
            result += self.__get_python_namespace__(c.namespace, parent_namespace='')
        return result

    def __get_python_namespace__(self, content, parent_namespace=''):
        namespace_name = content.name

        if len(parent_namespace) > 0:
            full_namespace = f'{parent_namespace}.{namespace_name}'
            namespace_nesting = len(full_namespace.split('.')) * '    '
            indent = '    '

        elif len(namespace_name) > 0:
            full_namespace = namespace_name
            namespace_nesting = ''
            indent = '    '
        else:
            full_namespace = ''
            namespace_nesting = ''
            indent = ''

        result = ''
        if len(namespace_name) > 0:
            result += f'class {namespace_name}:\n'

        full_pybind_name = f'cpp_m.{full_namespace.replace(".", "_")}'

        for e in content.enums:
            enum_lines = self.__create_enum__(e, full_pybind_name)
            result += self.__indent__(enum_lines, indent=indent, max_empty_lines=1)

        for c in content.classes:
            class_lines = self.__create_class__(c, full_pybind_name, full_namespace)
            result += self.__indent__(class_lines, indent=indent, max_empty_lines=1)

        for namespace in content.namespaces:
            t = content.namespaces[namespace]
            namespace_lines = self.__get_python_namespace__(t, full_namespace)
            result += self.__indent__(namespace_lines, indent=namespace_nesting, max_empty_lines=1)

        return result

    def __create_enum__(self, enum, full_pybind_name):
        enum_name = enum.typename.segments[0].name
        full_pybind_name += f'_{enum_name}'

        result = f'class {enum_name}({full_pybind_name}):\n{self.__get_class_docstring__(enum.doxygen)}'

        for enum_value in enum.values:
            val_name = enum_value.name
            result += f'    {val_name} = {full_pybind_name}.{val_name}\n'

        return result

    def __create_class__(self, c, full_pybind_name, python_namespace):
        class_name = c.class_decl.typename.segments[0].name

        if len(full_pybind_name) > 0 and full_pybind_name[-1] != '.':
            full_pybind_name += '_'

        full_pybind_name += f'{class_name}'
        full_python_name = f'{python_namespace}.{class_name}'

        is_virtual = self.__is_virtual__(c)

        if is_virtual:
            result = f'class {class_name}:\n'
        else:
            result = f'class {class_name}({full_pybind_name}):\n'

        if c.class_decl.doxygen is not None:
            doc = create_method_docstring(parse_doxygen_comment(c.class_decl.doxygen))
            result += self.__indent__(doc, indent='    ', max_empty_lines=1)

        for e in c.enums:
            enum_lines = self.__create_enum__(e, full_pybind_name)
            result += self.__indent__(enum_lines, indent='    ', max_empty_lines=1)

        for f in c.fields:
            if f.access != 'public':
                continue

            field_lines = self.__create_field__(f, full_python_name)
            result += self.__indent__(field_lines, indent='    ', max_empty_lines=1)

        for c in c.classes:
            if c.access != 'public':
                continue

            class_lines = self.__create_class__(c, full_pybind_name, full_python_name)
            result += self.__indent__(class_lines, indent='    ', max_empty_lines=1)

        methods = self.__get_class_methods__(c, full_python_name, is_virtual)
        result += self.__indent__(methods, indent='    ', max_empty_lines=1)

        return result

    def __create_field__(self, f, full_pybind_name):
        field_name = f.name

        result = '@property\n'
        result += f'def {field_name}(self):\n'

        if f.doxygen is not None:
            doc = create_field_docstring(f.doxygen)
            result += self.__indent__(doc, indent='    ', max_empty_lines=1)

        result += f'    return super({full_pybind_name}, {full_pybind_name}).{field_name}.__get__(self)\n\n'
        result += f'@{field_name}.setter\n'
        result += f'def {field_name}(self, value):\n'
        result += f'    super({full_pybind_name}, {full_pybind_name}).{field_name}.__set__(self, value)\n'

        return result

    def __get_class_docstring__(self, doxygen):
        if doxygen is None:
            return ''
        doc = create_method_docstring(parse_doxygen_comment(doxygen))
        return self.__indent__(doc, indent='    ', max_empty_lines=1)

    def __get_class_methods__(self, methods, namespace, is_virtual):
        # Collect all methods and overloaded methods with the number of parameters and doxygen
        method_dict = {}
        has_constructor = False
        if namespace.startswith('.'):
            namespace = namespace[1:]

        result = ''

        for m in methods.methods:
            if m.access != 'public':
                continue

            if m.destructor:
                continue

            name = m.name.segments[0].name

            if m.operator is not None:
                op = self.__valid_operator__(m)
                if len(op) > 0:
                    name = op
                else:
                    continue

            if m.static:
                decorator = '@staticmethod\n'
            else:
                decorator = ''

            if m.static:
                call_prefix = f'cpp_m.{namespace.replace(".", "_")}'
            elif is_virtual:
                call_prefix = 'self.__m__'
            else:
                call_prefix = 'super()'

            cpp_namespace = namespace.replace(".", "::")
            if f'{cpp_namespace}::{name}' in self.config.methods_to_ignore:
                continue

            if m.constructor:
                has_constructor = True
                name = '__init__'

            if name not in method_dict:
                method_dict[name] = []

            method_dict[name].append(
                {'params': len(m.parameters),
                 'doc': m.doxygen,
                 'return': m.return_type,
                 'decorator': decorator,
                 'call_prefix': call_prefix})

        if not has_constructor and not is_virtual:
            method_dict['__init__'] = [{'params': 0,
                                        'doc': None,
                                        'return': None,
                                        'decorator': '',
                                        'call_prefix': 'super()'}]

        for m in method_dict:
            tag = 'if'
            handled_number_of_params = []
            d = method_dict[m][0]
            decorator = d['decorator']
            self_tag = ''
            if decorator == '':
                self_tag = 'self, '

            result += f'{decorator}def {m}({self_tag}*args):\n'

            docs = []
            for p in method_dict[m]:
                if p['doc'] is not None:
                    docs.append(parse_doxygen_comment(p['doc']))
            doc_content = create_method_docstring(docs)
            if len(doc_content) > 0:
                result += self.__indent__(doc_content, indent='    ', max_empty_lines=1)

            for p in method_dict[m]:
                params = p['params']
                if params in handled_number_of_params:
                    continue

                result += f'    {tag} len(args) == {params}:\n'
                if p['return'] is None:
                    ret_type = ''
                else:
                    ret_type = 'return '

                call_prefix = p['call_prefix']
                result += f'        {ret_type}{call_prefix}.{m}('

                if params > 0:
                    for i in range(params):
                        result += f'args[{i}], '
                    result = result[:-2]
                result += ')\n\n'
                tag = 'elif'

                handled_number_of_params.append(params)

            result += f'    else:\n'
            result += f'        raise Exception("No matching method found for {m}")\n\n'

        if namespace in self.config.custom_methods:
            for m in self.config.custom_methods[namespace]:
                result += self.__indent__(m, '', 1)

        return result

    def __is_virtual__(self, c):
        for m in c.methods:
            if m.pure_virtual:
                return True
        return False

    @staticmethod
    def __indent__(lines, indent, max_empty_lines):
        result = ''
        empty_line_count = 0
        for li in lines.replace("\t", "    ").split('\n'):
            if li.strip() == '':
                empty_line_count += 1

                if empty_line_count > max_empty_lines:
                    continue

                result += '\n'
                continue

            empty_line_count = 0
            result += f'{indent}{li}\n'

        return result

    def __valid_operator__(self, m):
        if m.operator is None:
            return ''

        if m.operator not in self.config.operator_map:
            return ''

        if len(m.parameters) != 1:
            return ''

        return self.config.operator_map[m.operator]
