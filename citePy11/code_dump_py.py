from citePy11.simpleDoxyParser import *
from citePy11.code_dump_cpp import CodeDumpCpp


class CodeDumpPy:
    def __init__(self, code_dump_cpp: CodeDumpCpp, config):
        self.config = config
        self.dum_cpp = code_dump_cpp
        self.current_namespace = ''

    @staticmethod
    def get_python_head(module_name):
        result = """ # This File is autogenerated with citePy11 (Author: Sascha Schiwy)
        
import os
import sys
import enum

script_path = os.path.dirname(os.path.realpath(__file__))
sys.path.append(script_path)
"""

        result += f'\nimport __{module_name}__ as cpp_m\n\n'
        return result

    def get_python_content(self, result, content):
        result = ''
        for c in content:
            result += self.__get_python_namespace__(c.namespace, parent_namespace='')
        return result

    def __get_python_namespace__(self, content, parent_namespace=''):
        namespace_name = content.name

        if len(parent_namespace) > 0:
            full_namespace = f'{parent_namespace}.{namespace_name}'
            namespace_nesting = len(full_namespace.split('.')) * '    '

        elif len(namespace_name) > 0:
            full_namespace = namespace_name
            namespace_nesting = ''
        else:
            full_namespace = ''
            namespace_nesting = ''

        result = ''
        if len(namespace_name) > 0:
            result += f'class {namespace_name}:\n'

        full_pybind_name = f'cpp_m.{full_namespace.replace(".", "_")}'

        for e in content.enums:
            enum_lines = self.__create_enum__(e, full_pybind_name)
            result += self.__indent__(enum_lines, indent='    ', max_empty_lines=1)

        for c in content.classes:
            class_lines = self.__create_class__(c, full_pybind_name, full_namespace)
            result += self.__indent__(class_lines, indent='    ', max_empty_lines=1)

        for namespace in content.namespaces:
            t = content.namespaces[namespace]
            namespace_lines = self.__get_python_namespace__(t, full_namespace)
            result += self.__indent__(namespace_lines, indent=namespace_nesting, max_empty_lines=1)

        return result

    def __create_enum__(self, enum, full_pybind_name):
        enum_name = enum.typename.segments[0].name
        full_pybind_name += f'_{enum_name}'

        result = f'class {enum_name}({full_pybind_name}):\n{self.__get_class_docstring__(enum.doxygen)}'

        for enum_value in enum.values:
            val_name = enum_value.name
            result += f'    {val_name} = {full_pybind_name}.{val_name}\n'

        return result

    def __create_class__(self, c, full_pybind_name, python_namespace):
        class_name = c.class_decl.typename.segments[0].name
        full_pybind_name += f'_{class_name}'
        full_python_name = f'{python_namespace}.{class_name}'

        is_virtual = self.__is_virtual__(c)

        if is_virtual:
            result = f'class {class_name}:\n'
        else:
            result = f'class {class_name}({full_pybind_name}):\n'

        if c.class_decl.doxygen is not None:
            doc = create_method_docstring(parse_doxygen_comment(c.class_decl.doxygen))
            result += self.__indent__(doc, indent='    ', max_empty_lines=1)

        for e in c.enums:
            enum_lines = self.__create_enum__(e, full_pybind_name)
            result += self.__indent__(enum_lines, indent='    ', max_empty_lines=1)

        for f in c.fields:
            if f.access != 'public':
                continue

            field_lines = self.__create_field__(f, full_python_name)
            result += self.__indent__(field_lines, indent='    ', max_empty_lines=1)

        for c in c.classes:
            if c.access != 'public':
                continue

            class_lines = self.__create_class__(c, full_pybind_name, full_python_name)
            result += self.__indent__(class_lines, indent='    ', max_empty_lines=1)

        methods = self.__get_class_methods__(c, full_python_name, is_virtual)
        result += self.__indent__(methods, indent='    ', max_empty_lines=1)

        methods = self.__get_static_methods__(c, full_python_name, class_name)
        result += self.__indent__(methods, indent='    ', max_empty_lines=1)

        return result

    def __create_field__(self, f, full_pybind_name):
        field_name = f.name

        result = '@property\n'
        result += f'def {field_name}(self):\n'

        if f.doxygen is not None:
            doc = create_field_docstring(f.doxygen)
            result += self.__indent__(doc, indent='    ', max_empty_lines=1)

        result += f'    return super({full_pybind_name}, {full_pybind_name}).{field_name}.__get__(self)\n\n'
        result += f'@{field_name}.setter\n'
        result += f'def {field_name}(self, value):\n'
        result += f'    super({full_pybind_name}, {full_pybind_name}).{field_name}.__set__(self, value)\n'

        return result

    def __get_class_docstring__(self, doxygen):
        if doxygen is None:
            return ''
        doc = create_method_docstring(parse_doxygen_comment(doxygen))
        return self.__indent__(doc, indent='    ', max_empty_lines=1)

    def __get_class_methods__(self, methods, namespace, is_virtual):
        # Collect all methods and overloaded methods with the number of parameters and doxygen
        method_dict = {}
        has_constructor = False

        for m in methods.methods:
            if m.access != 'public':
                continue

            if m.destructor:
                continue

            if m.static:
                continue

            name = m.name.segments[0].name
            cpp_namespace = namespace.replace(".", "::")
            if f'{cpp_namespace}::{name}' in self.config.methods_to_ignore:
                continue

            if m.constructor:
                has_constructor = True
                name = '__init__'

            if name not in method_dict:
                method_dict[name] = []

            method_dict[name].append((len(m.parameters), m.doxygen, m.return_type))

        if not has_constructor and not is_virtual:
            method_dict['__init__'] = [(0, None, None)]

        result = ''

        for m in method_dict:
            tag = 'if'
            handled_number_of_params = []
            result += f'def {m}(self, *args):\n'

            docs = []
            for p in method_dict[m]:
                if p[1] is not None:
                    docs.append(parse_doxygen_comment(p[1]))
            doc_content = create_method_docstring(docs)
            if len(doc_content) > 0:
                result += self.__indent__(doc_content, indent='    ', max_empty_lines=1)

            for p in method_dict[m]:
                if p[0] in handled_number_of_params:
                    continue

                result += f'    {tag} len(args) == {p[0]}:\n'
                if p[2] is None:
                    ret_type = ''
                else:
                    ret_type = 'return '

                if is_virtual:
                    result += f'        {ret_type}self.__m__.{m}('
                else:
                    result += f'        {ret_type}super().{m}('

                if p[0] > 0:
                    for i in range(p[0]):
                        result += f'args[{i}], '
                    result = result[:-2]
                result += ')\n\n'
                tag = 'elif'

                handled_number_of_params.append(p[0])

            result += f'    else:\n'
            result += f'        raise Exception("No matching method found for {m}")\n\n'

        return result

    def __get_static_methods__(self, methods, namespace, class_name):
        # Collect all methods and overloaded methods with the number of parameters and doxygen
        method_dict = {}

        for m in methods.methods:
            if m.access != 'public':
                continue

            if not m.static:
                continue

            name = m.name.segments[0].name
            cpp_namespace = namespace.replace(".", "::")
            if f'{cpp_namespace}::{name}' in self.config.methods_to_ignore:
                continue

            if name not in method_dict:
                method_dict[name] = []

            method_dict[name].append((len(m.parameters), m.doxygen, m.return_type))

        result = ''
        for m in method_dict:
            tag = 'if'
            handled_number_of_params = []
            result += f'@staticmethod\ndef {m}(*args):\n'
            doc_content = '"""\n'

            for p in method_dict[m]:
                if p[0] in handled_number_of_params:
                    continue
                doc_content += create_method_docstring(parse_doxygen_comment(p[1]), skip_start_and_end=True)
                doc_content += 80 * '-' + '\n'

            doc_content += '"""\n'
            result += self.__indent__(doc_content, indent='    ', max_empty_lines=1)

            for p in method_dict[m]:
                if p[0] in handled_number_of_params:
                    continue

                result += f'    {tag} len(args) == {p[0]}:\n'
                if p[2] is None:
                    ret_type = ''
                else:
                    ret_type = 'return '

                full_pybind_name = f'{namespace.replace(".", "_")}'
                result += f'        {ret_type}cpp_m.{full_pybind_name}.{m}('

                if p[0] > 0:
                    for i in range(p[0]):
                        result += f'args[{i}], '
                    result = result[:-2]
                result += ')\n\n'
                tag = 'elif'

                handled_number_of_params.append(p[0])

            result += f'    else:\n'
            result += f'        raise Exception("No matching method found for {m}")\n\n'

        if namespace in self.config.custom_methods:
            for m in self.config.custom_methods[namespace]:
                result += self.__indent__(m, '', 1)

        return result

    def __is_virtual__(self, c):
        for m in c.methods:
            if m.pure_virtual:
                return True
        return False

    @staticmethod
    def __indent__(lines, indent, max_empty_lines):
        result = ''
        empty_line_count = 0
        for li in lines.replace("\t", "    ").split('\n'):
            if li.strip() == '':
                empty_line_count += 1

                if empty_line_count > max_empty_lines:
                    continue

                result += '\n'
                continue

            empty_line_count = 0
            result += f'{indent}{li}\n'

        return result
